Description: Resolve ambiguous overloading of private method
 When building with gcc 4.6, g++ gets confused about
 CProtocolUtil::writef(), since it's overloaded on the first
 parameter.  One version is void *, which gcc 4.6 considers
 equivalent when resolving ambiguities.  Since it's private,
 changing it to the real needed type (UInt8 *) resolves the
 problem.  This patch can be removed once all architectures
 have moved to using gcc 4.7 or later as the default compiler.
Author: Jeff Licquia <licquia@debian.org>
Forwarded: no
Last-Update: 2013-06-07
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
Index: synergy-1.4.12/src/lib/synergy/CProtocolUtil.cpp
===================================================================
--- synergy-1.4.12.orig/src/lib/synergy/CProtocolUtil.cpp	2013-06-01 22:55:47.000000000 +0000
+++ synergy-1.4.12/src/lib/synergy/CProtocolUtil.cpp	2013-06-07 17:37:27.000000000 +0000
@@ -336,9 +336,9 @@
 }
 
 void
-CProtocolUtil::writef(void* buffer, const char* fmt, va_list args)
+CProtocolUtil::writef(UInt8* buffer, const char* fmt, va_list args)
 {
-	UInt8* dst = reinterpret_cast<UInt8*>(buffer);
+	UInt8* dst = buffer;
 
 	while (*fmt) {
 		if (*fmt == '%') {
Index: synergy-1.4.12/src/lib/synergy/CProtocolUtil.h
===================================================================
--- synergy-1.4.12.orig/src/lib/synergy/CProtocolUtil.h	2013-06-01 22:55:47.000000000 +0000
+++ synergy-1.4.12/src/lib/synergy/CProtocolUtil.h	2013-06-07 17:34:31.000000000 +0000
@@ -79,7 +79,7 @@
 							const char* fmt, va_list);
 
 	static UInt32		getLength(const char* fmt, va_list);
-	static void			writef(void*, const char* fmt, va_list);
+	static void			writef(UInt8*, const char* fmt, va_list);
 	static UInt32		eatLength(const char** fmt);
 	static void			read(synergy::IStream*, void*, UInt32);
 };
