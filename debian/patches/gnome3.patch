Description: GNOME 3 fix
 This patch fixes an incompatibility with Synergy and GNOME 3.
Bug: http://synergy-foss.org/tracker/issues/2958
Origin: http://synergy-foss.org/tracker/projects/synergy/repository/revisions/1157
Forwarded: not-needed
Last-Update: 2011-12-04

=== modified file 'CMakeLists.txt'
--- old/CMakeLists.txt	2011-11-21 01:52:49 +0000
+++ new/CMakeLists.txt	2011-12-04 23:56:46 +0000
@@ -178,6 +178,8 @@
 		check_include_files("X11/extensions/XTest.h" HAVE_X11_EXTENSIONS_XTEST_H)
 		check_include_files(${XKBlib} HAVE_X11_XKBLIB_H)
 
+		check_include_files("X11/extensions/XInput2.h" HAVE_XI2)
+
 		if (HAVE_X11_EXTENSIONS_DPMS_H)
 			# Assume that function prototypes declared, when include exists.
 			set(HAVE_DPMS_PROTOTYPES 1)
@@ -191,6 +193,7 @@
 		check_library_exists("X11;Xext" DPMSQueryExtension "" HAVE_Xext)
 		check_library_exists("X11;Xext;Xtst" XTestQueryExtension "" HAVE_Xtst)
 		check_library_exists("Xinerama" XineramaQueryExtension "" HAVE_Xinerama)
+		check_library_exists("Xi" XISelectEvents "" HAVE_Xi)
 
 		if (HAVE_ICE)
 
@@ -224,6 +227,10 @@
 			endif()
 		endif()
 
+		if (HAVE_Xi)
+			list(APPEND libs Xi)
+		endif()
+
 	endif()
 
 	# For config.h, set some static values; it may be a good idea to make

=== modified file 'res/config.h.in'
--- old/res/config.h.in	2011-09-18 17:44:28 +0000
+++ new/res/config.h.in	2011-12-04 23:56:46 +0000
@@ -124,6 +124,9 @@
 /* Define to 1 if you have the <X11/XKBlib.h> header file. */
 #cmakedefine HAVE_X11_XKBLIB_H ${HAVE_X11_XKBLIB_H}
 
+/* Define to 1 if you have the <X11/extensions/XInput2.h> header file. */
+#cmakedefine HAVE_XI2 ${HAVE_XI2}
+
 /* Define this if the XKB extension is available. */
 #cmakedefine HAVE_XKB_EXTENSION ${HAVE_XKB_EXTENSION}
 

=== modified file 'src/lib/platform/CXWindowsEventQueueBuffer.cpp'
--- old/src/lib/platform/CXWindowsEventQueueBuffer.cpp	2011-09-18 17:44:28 +0000
+++ new/src/lib/platform/CXWindowsEventQueueBuffer.cpp	2011-12-04 23:56:46 +0000
@@ -177,7 +177,7 @@
 						SELECT_TYPE_ARG234 NULL,
 						SELECT_TYPE_ARG234 NULL,
 						SELECT_TYPE_ARG5   TIMEOUT_DELAY);
-	if (FD_SET(m_pipefd[0], &rfds) {
+	if (FD_SET(m_pipefd[0], &rfds)) {
 		read(m_pipefd[0], buf, 15);
 	}
 #endif

=== modified file 'src/lib/platform/CXWindowsScreen.cpp'
--- old/src/lib/platform/CXWindowsScreen.cpp	2011-09-18 17:44:28 +0000
+++ new/src/lib/platform/CXWindowsScreen.cpp	2011-12-04 23:56:46 +0000
@@ -59,9 +59,13 @@
 #	if HAVE_XKB_EXTENSION
 #		include <X11/XKBlib.h>
 #	endif
+#	ifdef HAVE_XI2
+#		include <X11/extensions/XInput2.h>
+#	endif
 #endif
 #include "CArch.h"
 
+static int xi_opcode;
 
 //
 // CXWindowsScreen
@@ -102,7 +106,8 @@
 	m_screensaverNotify(false),
 	m_xtestIsXineramaUnaware(true),
 	m_preserveFocus(false),
-	m_xkb(false)
+	m_xkb(false),
+	m_xi2detected(false)
 {
 	assert(s_screen == NULL);
 
@@ -140,8 +145,15 @@
 
 	// primary/secondary screen only initialization
 	if (m_isPrimary) {
-		// start watching for events on other windows
-		selectEvents(m_root);
+		m_xi2detected = detectXI2();
+
+		if (m_xi2detected) {
+			selectXIRawMotion();
+		} else
+		{
+			// start watching for events on other windows
+			selectEvents(m_root);
+		}
 
 		// prepare to use input methods
 		openIM();
@@ -1205,6 +1217,39 @@
 		return;
 	}
 
+	if (m_xi2detected) {
+		// Process RawMotion
+		XGenericEventCookie *cookie = (XGenericEventCookie*)&xevent->xcookie;
+
+		if (XGetEventData(m_display, cookie) &&
+				cookie->type == GenericEvent &&
+				cookie->extension == xi_opcode) {
+			if (cookie->evtype == XI_RawMotion) {
+				// Get current pointer's position
+				Window root, child;
+				XMotionEvent xmotion;
+				xmotion.type = MotionNotify;
+				xmotion.send_event = False; // Raw motion
+				xmotion.display = m_display;
+				xmotion.window = m_window;
+				/* xmotion's time, state and is_hint are not used */
+				unsigned int msk;
+
+				xmotion.same_screen = XQueryPointer(
+						m_display, m_root, &xmotion.root, &xmotion.subwindow, 
+						&xmotion.x_root,
+						&xmotion.y_root,
+						&xmotion.x,
+						&xmotion.y,
+						&msk);
+
+				onMouseMove(xmotion);
+
+				return;
+			}
+		}
+	}
+
 	// handle the event ourself
 	switch (xevent->type) {
 	case CreateNotify:
@@ -1954,3 +1999,27 @@
 	return (m_keycode < x.m_keycode ||
 			(m_keycode == x.m_keycode && m_mask < x.m_mask));
 }
+
+bool
+CXWindowsScreen::detectXI2()
+{
+	int event, error;
+    return XQueryExtension(m_display, 
+			"XInputExtension", &xi_opcode, &event, &error);
+}
+
+void
+CXWindowsScreen::selectXIRawMotion()
+{
+	XIEventMask mask;
+
+	mask.deviceid = XIAllDevices;
+	mask.mask_len = XIMaskLen(XI_RawMotion);
+	mask.mask = (unsigned char*)calloc(mask.mask_len, sizeof(char));
+	mask.deviceid = XIAllMasterDevices;
+	memset(mask.mask, 0, 2);
+    XISetMask(mask.mask, XI_RawKeyRelease);
+	XISetMask(mask.mask, XI_RawMotion);
+	XISelectEvents(m_display, DefaultRootWindow(m_display), &mask, 1);
+	free(mask.mask);
+}

=== modified file 'src/lib/platform/CXWindowsScreen.h'
--- old/src/lib/platform/CXWindowsScreen.h	2011-09-18 17:44:28 +0000
+++ new/src/lib/platform/CXWindowsScreen.h	2011-12-04 23:56:46 +0000
@@ -132,6 +132,8 @@
 	void				onMouseRelease(const XButtonEvent&);
 	void				onMouseMove(const XMotionEvent&);
 
+	bool				detectXI2();
+	void				selectXIRawMotion();
 	void				selectEvents(Window) const;
 	void				doSelectEvents(Window) const;
 
@@ -229,6 +231,8 @@
 	bool				m_xkb;
 	int					m_xkbEventBase;
 
+	bool				m_xi2detected;
+
 	// pointer to (singleton) screen.  this is only needed by
 	// ioErrorHandler().
 	static CXWindowsScreen*	s_screen;

